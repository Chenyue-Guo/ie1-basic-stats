Group Members:
Chenyue Guo: Owner of the fork repository (email chenyueguo@umass.edu)
Zhehuan Chen: Collaborator of the fork repository (email zhehuanchen@umass.edu)
Repository URL: https://github.com/Chenyue-Guo/ie1-basic-stats.git
===========================================================
Question 1.
-----------------------------------------------------------
Query 1. The answer is:
16

(Use "git log --oneline -- README.md")
-----------------------------------------------------------
Query 2. The answer is:
DeveloperTommy
René Just
rjust
Yuriy Brun

(Use "git log --format='%an' README.md")
-----------------------------------------------------------
Query 3. The answer is:
c2111cc0d37bfde779a317e533d3a5e68b8ed9e3

(Use "git log --grep="Ant" README.md")
-----------------------------------------------------------
Query 4. The answer is:
82

(Use "git rev-list --all --count")
-----------------------------------------------------------
Query 5. The answer is:
src/Models/Model.java
src/Models/Numbers.java
src/Views/AddNumView.java
src/Views/MeanView.java
src/Views/MedianView.java
src/Views/ModeView.java
src/Views/NumbersView.java
src/Views/ResetView.java

(Use "git diff-tree --no-commit-id --name-only -r 01da475")
-----------------------------------------------------------
Query 6. The answer is:
da90e878188c6de8870581bdb447299821d7e87b

(Use "git log -1")
===========================================================
Question 2.
-----------------------------------------------------------
1. Initiate the repository:

Step 1: Clone the repo
# For the owner:
# ... Fork basic-stats on Github website profile.
git clone https://github.com/LASER-UMASS/basic-stats basic-stats-fork
cd basic-stats-fork
git remote set-url origin https://github.com/Chenyue-Guo/ie1-basic-stats.git
git push

# For the collaborator:
git clone https://github.com/Chenyue-Guo/ie1-basic-stats.git basic-stats-fork
cd basic-stats-fork

Step 2: Initialize configures:
# ... Create or edit .gitignore, adding files that should not be versioned (like bin).
# ... Push changed configures to the branch. (See "3. Steps for pushing the changes to the remote repository.")

Step 3: Create branches individually for part of features.
# Optionally, create a src/MinMaxCalculation.java and push it to the master branch.
# The SHA of the commit where we create MinMaxCalculation.java is 319756e197f99116bf2dbd9353de4ae05edda95c.
git checkout -b feature/chenyue/max-calculation		# branch named with "<functionality>/<collaborator>/<feature-name>"
git push --set-upstream origin feature/chenyue/max-calculation

# git switch master
git checkout -b feature/zhehuan/min-calculation
git push --set-upstream origin feature/zhehuan/min-calculation
-----------------------------------------------------------
2. Manage merges in the context of collabortive development:

Synchronize with main branch:
git fetch origin
git merge origin/master
# ... Manually resolve some conflicts (if they arise)
# ... Edit some files in the repository

When feature on this branch is completed:
# ... Create a pull request from feature branch to main branch on Github website.
# ... Maintainer resolve the conflicts on the feature branch so that it can auto-merge into main branch.
# ... Confirm merge PR in Github website.
# git switch master
git pull
-----------------------------------------------------------
3. Steps for pushing the changes to the remote repository.

Step 1: Pull changes from remote repository.
# ... Make edits on current branch.
git pull
# ... Manually resolve some conflicts (if they arise)

Step 2: Add the resolved conflicts and edited files to commit.
git add src/MinMaxCalculation.java [src/ConflictedFiles.java src/OtherFiles.java]
git commit -m "Commit Messages, e.g., Add min function in MinMaxCalculation.java"


Step 3: Push commits to branch.
git push
===========================================================
Question 3.
-----------------------------------------------------------
The answer is: 14.
No, the commit hashes of the cherry-picked commits are not identical in the main and feature-branch. When we cherry-pick a commit, Git creates a new commit with a new hash in the target branch, even though the content and commit message are the same.
-----------------------------------------------------------
Here are the commands and results we execute on the "Cherry-pick" section:

git checkout tags/v1.0.0
git checkout -b feature-branch
gitk --all

git log --oneline main -- README.md

# in master branch
da90e87 (HEAD -> master, upstream/master, upstream/HEAD, origin/master, origin/HEAD) Updated README.md
aad2f3e Updated the test command
0f983c1 tweaked the program features description
913a5d8 cleared up running instructions
61ffac5 clearing up step 5
ddc3fac clearing up step 4
9712b04 clearing up step 3
c2b3163 clearing up step 2
c2111cc added more info about Ant
3e2a0a5 improved description
a2583e6 Updated README file.
4fa7109 Tweaked the README.
f60980c Updated README
e0ca8e1 Updated the README
ba319db Updated README.
9b1bbb2 Initial commit

git log --oneline README.md

# in feature branch
ba319db Updated README.
9b1bbb2 Initial commit

git cherry-pick e0ca8e1 f60980c 4fa7109 a2583e6 3e2a0a5 c2111cc c2b3163 9712b04 ddc3fac 61ffac5 913a5d8 0f983c1 aad2f3e da90e87
gitk --all
git push --set-upstream origin feature-branch
===========================================================
Question 4.
-----------------------------------------------------------
When we merge a branch from which we previously cherry-picked single commits, the commits "appear" again. That means the cherry-picked commits will appear twice in the history. Once as the cherry-picked commits, and once as the original commits that come in through the merge. The reason for this duplication is that cherry-picking creates new commits with new hashes, even though the content is the same. When we merge the original branch, Git does not recognize the cherry-picked commits as the same because their hashes are different.
===========================================================
Question 5.
-----------------------------------------------------------
Risk 1: Conflicts with Rebasing Commits.
Rebasing a branch that is already present on both the remote and local repositories can cause divergence. The rebased commits will differ from the original commits on the remote. When attempting to pull from the remote branch, the original commits will be pulled again, leading to conflicts that can be challenging to resolve.

Risk 2: Rewriting History.
Rebasing a branch that is already shared on the remote repository rewrites the commit history. When force pushing the rebased branch, it overwrites the remote branch’s history. This action discards the original commits on the remote, potentially causing lost work and confusion for collaborators who have based their work on those original commits.

A safe use case for rebasing:

When working on a feature branch that has not yet been shared with others:
A---B---C---F---G (main)
     \
      D---E (feature)

Then rebase the feature branch onto the main branch with:
git checkout feature
git rebase main

As a result, the commit history will look like this:
A---B---C---F---G (main)
                 \
                  D'---E' (feature)

In this case, rebasing is safe because:
The feature branch has not been shared with others, so no one else is affected by the rewritten history. This allows for incorporating the latest changes from the main branch into the feature branch cleanly, without creating a merge commit.
-----------------------------------------------------------
Here are the commands we execute on the "Rebase" section:

git rebase -i HEAD~4
gitk --all
git pull --no-rebase
gitk --all
git push
===========================================================
Question 6.
-----------------------------------------------------------
Resetting to a commit that has already been pushed can cause discrepancies between your local and remote repositories. If you then make changes locally, it might lead to conflicts when performing the next pull. Furthermore, resetting commits can result in the loss of useful work or conflicts with some useless work, requiring you to repeat tasks and costing a significant amount of time.
===========================================================
Question 7.
-----------------------------------------------------------
No, "git revert" does not remove the reverted commit. Instead, it creates a new commit that undoes the changes introduced by the specified commit. Git records all changes to the repository, so performing a revert adds a new commit that undoes the changes introduced by the original commit. For example, if you added a new line to the code, the revert operation will remove that line. Similarly, if you deleted any characters, the revert operation will restore them.
-----------------------------------------------------------
Here are the commands we execute on the "Reset & revert" section:

# .. Edit README.md and then commit.
git reset HEAD~1
# .. Further edit README.md and then commit and push.
git revert HEAD
git push
git log --oneline --graph
