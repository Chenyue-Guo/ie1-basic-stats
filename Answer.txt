Group Members:
Chenyue Guo: Owner of the fork repository
Zhehuan Chen: Collaborator of the fork repository
Repo URL: https://github.com/Chenyue-Guo/ie1-basic-stats.git
===========================================================
Question 1.
-----------------------------------------------------------
Query 1. The answer is:
16

(Use "git log --oneline -- README.md")
-----------------------------------------------------------
Query 2. The answer is:
DeveloperTommy
RenÃ© Just
rjust
Yuriy Brun

(Use "git log --format='%an' README.md")
-----------------------------------------------------------
Query 3. The answer is:
c2111cc0d37bfde779a317e533d3a5e68b8ed9e3

(Use "git log --grep="Ant" README.md")
-----------------------------------------------------------
Query 4. The answer is:
82

(Use "git rev-list --all --count")
-----------------------------------------------------------
Query 5. The answer is:
src/Models/Model.java
src/Models/Numbers.java
src/Views/AddNumView.java
src/Views/MeanView.java
src/Views/MedianView.java
src/Views/ModeView.java
src/Views/NumbersView.java
src/Views/ResetView.java

(Use "git diff-tree --no-commit-id --name-only -r 01da475")
-----------------------------------------------------------
Query 6. The answer is:
da90e878188c6de8870581bdb447299821d7e87b

(Use "git log -1")
===========================================================
Question 2.
-----------------------------------------------------------
1. Initiate the repository:

Step 1: Clone the repo
# For the owner:
# ... Fork basic-stats on Github website profile.
git clone https://github.com/LASER-UMASS/basic-stats basic-stats-fork
cd basic-stats-fork
git remote set-url origin https://github.com/Chenyue-Guo/ie1-basic-stats.git
git push

# For the collaborator:
git clone https://github.com/Chenyue-Guo/ie1-basic-stats.git basic-stats-fork
cd basic-stats-fork

Step 2: Initialize configures:
# ... Create or edit .gitignore, adding files that should not be versioned (like bin).
# ... Push changed configures to the branch. (See "3. Steps for pushing the changes to the remote repository.")

Step 3: Create branches individually for part of features.
# Optionally, create a src/MinMaxCalculation.java and push it to the master branch.
git checkout -b feature/chenyue/max-calculation		# branch named with "functionality/collaborator/description"
git push --set-upstream origin feature/chenyue/max-calculation

# git switch master
git checkout -b feature/zhehuan/min-calculation
git push --set-upstream origin feature/zhehuan/min-calculation
-----------------------------------------------------------
2. Manage merges in the context of collabortive development:

Synchronize with main branch:
git fetch origin
git merge origin/master         
# ... Manually resolve some conflicts (if they arise)
# ... Edit some files in the repository

When feature on this branch is completed:
# ... Create a pull request from feature branch to main branch on Github website.
# ... Maintainer resolve the conflicts on the feature branch so that it can auto-merge into main branch.
# ... Confirm merge PR in Github website.
# git switch master
git pull
-----------------------------------------------------------
3. Steps for pushing the changes to the remote repository.

Step 1: Pull changes from remote repository.
# ... Make edits on current branch.
git pull
# ... Manually resolve some conflicts (if they arise)

Step 2: Add the resolved conflicts and edited files to commit.
git add src/MinMaxCalculation.java [src/ConflictedFiles.java src/OtherFiles.java]
git commit -m "Commit Messages, e.g., Add min function in MinMaxCalculation.java"


Step 3: Push commits to branch.
git push
===========================================================
Question 3.
-----------------------------------------------------------
The answer is: 14.
No, the commit hashes of the cherry-picked commits are not identical in the main and feature-branch. When I cherry-pick a commit, Git creates a new commit with a new hash in the target branch, even though the content and commit message are the same.
===========================================================
Question 4.
-----------------------------------------------------------
When I merge a branch from which I previously cherry-picked single commits, the commits "appear" again. That means the cherry-picked commits will appear twice in the history. Once as the cherry-picked commits, and once as the original commits that come in through the merge. The reason for this duplication is that cherry-picking creates new commits with new hashes, even though the content is the same. When I merge the original branch, Git does not recognize the cherry-picked commits as the same because their hashes are different.
===========================================================
Question 5.
-----------------------------------------------------------
Risk 1: Rewriting History
Rebasing changes the commit history by creating new commits with new hashes. This can be problematic if the branch has already been shared with others, as it can lead to confusion and difficulties in collaboration.
Example: If you rebase a branch that has been pushed to a shared repository, your collaborators will need to force-pull the changes, which can lead to lost work or conflicts.
Risk 2: Loss of Context
Rebasing can lose the context of how changes were made, especially if there were important merge commits that provided context for the integration of different branches.
Example: If you rebase a branch that had multiple merge commits, the history will no longer show how different branches were integrated, making it harder to understand the development process.


Examples:


====================
No, git revert does not remove the reverted commit. Instead, it creates a new commit that undoes the changes introduced by the specified commit.

Collaborate:
1.
319756e197f99116bf2dbd9353de4ae05edda95c


Cherry-pick:
1.
git checkout tags/v1.0.0
git checkout -b feature-branch
gitk --all

3.
git log --oneline README.md

da90e87 (HEAD -> master, upstream/master, upstream/HEAD, origin/master, origin/HEAD) Updated README.md
aad2f3e Updated the test command
0f983c1 tweaked the program features description
913a5d8 cleared up running instructions
61ffac5 clearing up step 5
ddc3fac clearing up step 4
9712b04 clearing up step 3
c2b3163 clearing up step 2
c2111cc added more info about Ant
3e2a0a5 improved description
a2583e6 Updated README file.
4fa7109 Tweaked the README.
f60980c Updated README
e0ca8e1 Updated the README
ba319db Updated README.
9b1bbb2 Initial commit

ba319db Updated README.
9b1bbb2 Initial commit

git cherry-pick e0ca8e1 f60980c 4fa7109 a2583e6 3e2a0a5 c2111cc c2b3163 9712b04 ddc3fac 61ffac5 913a5d8 0f983c1 aad2f3e da90e87

5.
git push --set-upstream origin feature-branch 


Rebase:

git rebase -i HEAD~4
git log --oneline --graph
git pull
git log --oneline --graph
git push


Reset:

Merge Conflicts: If your local changes (before the reset) and the changes from the remote repository are different, you might encounter merge conflicts that need to be resolved manually.
Diverging Histories: If you reset your branch to a previous commit and then pull, your local branch history might diverge from the remote branch. This can lead to a complex merge situation.
Overwriting Changes: If you use git reset --hard and then pull, you might overwrite local changes with the remote changes, potentially losing important work.

git reset HEAD~1
git revert HEAD
git push
git log --oneline --graph


Question 2.



Use descriptive names for branches, such as feature/<feature-name>, bugfix/<issue-description>, etc.
Commit Messages:
Write clear and concise commit messages that describe the changes made.
Using .gitignore:
Create a .gitignore file to exclude files that should not be versioned (e.g., build files, temporary files, sensitive information):
touch .gitignore
echo "build/" >> .gitignore
echo "*.log" >> .gitignore
git add .gitignore
git commit -m "Add .gitignore to exclude build files and logs"

